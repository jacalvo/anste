# Copyright (C) 2007-2011 José Antonio Calvo Fernández <jacalvo@zentyal.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

package ANSTE::ScriptGen::HostImageSetup;

use strict;
use warnings;

use ANSTE::Scenario::Host;
use ANSTE::Scenario::NetworkInterface;
use ANSTE::Config;
use ANSTE::Exceptions::MissingArgument;
use ANSTE::Exceptions::InvalidType;
use ANSTE::Exceptions::InvalidFile;
use ANSTE::System::System;

use Perl6::Junction qw(any);

# Class: HostImageSetup
#
#   Writes the setup script for a host image (a copy of a base image)
#   that needs to be executed with the virtual machine running.
#

# Constructor: new
#
#   Constructor for HostImageSetup class.
#
# Parameters:
#
#   host - <ANSTE::Scenario::Host> object.
#
# Returns:
#
#   A recently created <ANSTE::ScriptGen::HostImageSetup> object.
#
# Exceptions:
#
#   <ANSTE::Exceptions::MissingArgument> - throw if argument is not present
#   <ANSTE::Exceptions::InvalidType> - throw if argument has wrong type
#
sub new # (host) returns new HostImageSetup object
{
    my ($class, $host) = @_;
    my $self = {};

    defined $host or
        throw ANSTE::Exceptions::MissingArgument('host');

    if (not $host->isa('ANSTE::Scenario::Host')) {
        throw ANSTE::Exceptions::InvalidType('host',
                                            'ANSTE::Scenario::Host');
    }

    $self->{host} = $host;
    $self->{system} = ANSTE::System::System->instance();

    bless($self, $class);

    return $self;
}

# Method: writeScript
#
#   Writes the script to the given file.
#
# Parameters:
#
#   file - String with the name of the file to be written.
#
# Exceptions:
#
#   <ANSTE::Exceptions::MissingArgument> - throw if argument is not present
#   <ANSTE::Exceptions::InvalidFile> - throw if argument is not a writable file
#
sub writeScript # (file)
{
    my ($self, $file) = @_;

    defined $file or
        throw ANSTE::Exceptions::MissingArgument('file');

    if (not -w $file) {
        throw ANSTE::Exceptions::InvalidFile('file', $file);
    }

    print $file "#!/bin/sh\n";
    my $name = $self->{host}->name();
    my $desc = $self->{host}->desc();
    print $file "\n# Configuration file for host $name\n";
    print $file "# Server description: $desc\n";
    print $file "# Generated by ANSTE\n\n";

    $self->_addTemporaryNameServer($file);

    my @packages = @{$self->{host}->packages()->list()};
    if (@packages) {
        $self->_writePreInstall($file);
        $self->_writePackageInstall($file, @packages);
        $self->_writePostInstall($file);
    }
    $self->_writeNetworkConfig($file);
    $self->_writeHostsConfig($file);
}

sub _addTemporaryNameServer # (file)
{
    my ($self, $file) = @_;

    my $system = $self->{system};
    my $nameserver = ANSTE::Config->instance()->nameserver();
    print $file "# Add temporary nameServer\n";
    my $command = "echo 'nameserver $nameserver' > /etc/resolv.conf\n";
    print $file "$command\n\n";
}

sub _writePreInstall # (file)
{
    my ($self, $file) = @_;

    my $system = $self->{system};

    my $vars = $system->installVars();
    print $file $vars;

    my $command = $system->updatePackagesCommand();
    print $file "$command\n\n";
}

sub _writePackageInstall # (file, @packages)
{
    my ($self, $file, @packages) = @_;

    my $system = $self->{system};

    print $file "# Install packages\n";
    my $command = $system->installPackagesCommand(@packages);
    print $file "$command\n\n";
}

sub _writePostInstall # (file)
{
    my ($self, $file) = @_;

    my $system = $self->{system};

    my $command = $system->cleanPackagesCommand();

    print $file "$command\n\n";
}

sub _writeNetworkConfig # (file)
{
    my ($self, $file) = @_;

    my $system = $self->{system};
    my $host = $self->{host};

    my $config = $system->networkConfig($host->network());

    print $file "# Write network configuration\n";
    print $file "$config\n\n";

    print $file "# Update network configuration\n";
    my $command = $system->updateNetworkCommand();
    print $file "$command\n\n";

    if ($host->isRouter()) {
        print $file "# Enable routing\n";
        my @ifaces = (ANSTE::Config->instance()->commIface());
        foreach my $iface (@{$host->network()->interfaces()}) {
            if ($iface->external()) {
                push(@ifaces, $iface->name());
            }
        }
        my $cmd = $system->enableRouting(@ifaces);
        print $file "$cmd\n";
    }
    my $type = $host->type();
    if ($type eq any('dhcp-router', 'pppoe-router')) {
        print $file "# Execute setup for type $type\n";
        my $cmd = $system->installPackagesCommandType($type);
        print $file "$cmd\n";
        $cmd = $system->setupTypeScript($type);
        print $file "$cmd\n";
    }
}

sub _writeHostsConfig # (file)
{
    my ($self, $file) = @_;

    my $system = $self->{system};
    my $thisHost = $self->{host};

    my %hostAddress;

    my $hosts = $thisHost->scenario()->hosts();
    my $myInterfaces = $thisHost->network()->interfaces();

    foreach my $host (@{$hosts}) {
        my $hostname = $host->name();

        # Skip this host
        next if $hostname eq $thisHost->name();

        # Check if the host has an interface in the same
        # network of our host
        my $address = _addressInNetwork($host->network()->interfaces(),
                                        $myInterfaces);
        if ($address) {
            $hostAddress{$hostname} = $address;
        }
    }

    if (%hostAddress) {
        my $config = $system->hostsConfig(%hostAddress);
        print $file "# Write hosts configuration\n";
        print $file "$config\n\n";
    }
}

sub _addressInNetwork # (hostInterfaces, myInterfaces)
{
    my ($hostInterfaces, $myInterfaces) = @_;

    foreach my $myIface (@{$myInterfaces}) {
        next if $myIface->type() ==
            ANSTE::Scenario::NetworkInterface::IFACE_TYPE_DHCP;

        my $myMask = $myIface->netmask();
        my $myMaskBits = _octetsToNumber($myMask);
        my $myAddress = $myIface->address();
        my $myAddressBits = _octetsToNumber($myAddress);

        foreach my $hostIface (@{$hostInterfaces}) {
            next if $hostIface->type() ==
                ANSTE::Scenario::NetworkInterface::IFACE_TYPE_DHCP;

            my $hostMask = $hostIface->netmask();
            my $hostMaskBits = _octetsToNumber($hostMask);
            my $hostAddress = $hostIface->address();
            my $hostAddressBits = _octetsToNumber($hostAddress);

            if (($myAddressBits & $myMaskBits) ==
                ($hostAddressBits & $hostMaskBits)) {
                return $hostAddress;
            }
        }
    }
    return undef;
}

sub _octetsToNumber # (str)
{
    my ($str) = @_;
    return unpack("L", pack("CCCC", split(/\./, $str)));
}

1;
